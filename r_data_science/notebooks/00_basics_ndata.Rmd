---
title: "R Notebook"
output: 
    html_notebook:
        toc: true
        toc_depth: 3
---

# The very basics

## Getting Help

At the command line we can look for help through the commands:

-   `help()`: gets information on a particular R function, e.g. `help(matrix)`

-   `?`: works the same as the previous one, e.g. `?"matrix"`

-   `help.search()`: It's useful if we know the subject rather than the name.

-   `apropos()`: returns a vector of names of objects containing that string, e.g. `apropos("matrix")` returns every object with 'matrix' in its name.

-   `args()`: displays the set of arguments expected by a given function.

```{r}
args(matrix)
```

# R Data: Vectors

A vector is the basic unit of computation in R. The atomic clases which we can see with `help(vector)` are::

-   logical: TRUE or FALSE (T or F as synonyms)
-   integer
-   numeric or double
-   character: is the text
-   raw: can hold binary data
-   complex

To combines items into a vector we use `c()` function. Cal also be used to combine vector, as long as all the vectors are of the same sort.

```{r}
c(2, 25)
```

```{r}
# R has formatted the numbers in a consistent way
c(-2, pi, 25)
```

```{r}
c(c(2, 3), c(pi, 16.7, 5), c(-12, -16))
```

To set consecutive integers:

```{r}
1:7
```

```{r}
# Sequence in reverse
9:-2
```

```{r}
# It's 3 plus the sequence
3 + 2:5
```

Using `help(Syntax)` It can be seen a list of operators and their precedences, and precedence can always be over-ridden with parentheses.

Also with `seq()` we can create sequences, with better control of starting points, ending points, lengths, and step sizes. With help we can see:

``` r
seq(...)

## Default S3 method:
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)

# Examples:
seq(17)
seq(0, 1, length.out = 11)
seq(1, 9, by = 2)
```

Logical vectors ofen are constructed by R in response to an operation:

```{r}
35:41 >= 37
```

To calculate the number or proportions of elements in a vector we use `sum()` for count and `mean()` for proportions:

```{r}
# like we saw, five out of seven elements in this vector are greater or equal to 37
sum(35:41 >= 37)
```

```{r}
# 5 out of 7 are aprox. 71.4%
mean(35:41 >= 37)
```

## Vector Operations

Arithmetic operations on vectors produce vectors.

```{r}
5:10
```

```{r}
(5:10)^2
```

There are functions which returns a single number (that is also a vector), such as: `length(), sum(), mean(), sd(), min(), max()`. The function `range()` returns the smallest and largest values, and `summary()` returns a vector of summary statistics.

```{r}
# An assigment with parentheses case print this assigment
(th1 <- c(20, 15, 10, 5, 0)^2)
```

```{r}
th2 <- 105:101
th2 + th1
```

```{r}
th2 / th1
```

It's Computed element by element, that's why print 'Inf', because 101/0 refer to an infinite value.

```{r}
# Print the larger value anywhere
max(th1, th2)
```

```{r}
# 'Parallel maximum' print the larger of each pair
pmax(th2, th1)
```

Loginac vectors can also be combined. The operator `|` for 'or' return TRUE if either element is TRUE; the `&` operator for 'and' return TRUE only if both elements are TRUE. This single version evaluate the condition for every pair of elements from both vectors, the double version ( `|| , &&`) evaluate multiple TRUE/FALSE conditions from left to right, stopping as soon as possible (are useful in `if()` statements).

Recycling

When a vector does not match with other vector to be operated, the shorter one starts again, recycling it's elements.

```{r}
# Two vector with the same length, 6
5:10 + c(0, 10, 100, 1000, 10000, 100000)
# The sum is element by element
```

```{r}
# Two vectors, 6 and 3 elements
5:10 + c(1, 10, 100)
```

```{r}
# 6-vector and 5 vector. The second recycle it's first element (10 + 3)
5:10 + c(3, 4, 5, 6, 7)

```

Recycling a vector of length 1 (`(5:10) + 4`) is very common, but the other lengths ir rarer. If we see the last warning, It's better to treat that as an error and try to resolve it.

## Handling character vectors

We can add names to a vector to identify individual entries. R accept letters, numbers, dots, and underscores:

```{r}
vec <- c(201, 202, 203)
names(vec)
```

```{r}
# It is a bad practice to have a vector's name invalid:
names(vec) <- c("a", "b", "with space")
names(vec)
```

```{r}
# Also, we can assign names directly
vec <- c(a = 201, b = 202, with.space = 203)
vec
```

## Data Types

The most common data types are numeric, logical and character. These are some less-common data types:

-   integers: values between -(2^31^ -1) and 2^31^ -1. Values outside this range may be displayed as integers but will be stored as doubles. To regard an item as an integer you can add `L` on its end ( `246L` ), this only makes sense whether really is an integer.
-   raw: refers to data kept in binary (hexadecimal) form. Is data from images, sound and video, R will stored as raw. It can be converted into character data with `rawToChar()` function. Reading raw data could be useful to handle the case of unexpected characters.
-   complex number: R can manipulate complex numbers but almost never arise in data cleaning.

We can see what data type is a vector with `typeof()` which differentiates between integer and double. Other function called `mode()` calls them both numeric. The `str()` function return the data type and the first few entries. And `class()` is more general operator for complex types.

The functions: `is.logical(), is.integer(), is.numeric(), is.character()` returns a single logical value whether is TRUE or FALSE. A particularly useful function for more complicated or user-defined clases is `is()` which lets you specify the class as an argument: `is(pi, "numeric")`.

```{r}
typeof(vec)
```

```{r}
mode(vec)
```

### Data Type conversion

R modifies the entire vector to be of the more complicated type. If you create a numeric vector but you adds a character, the entire vector will be converted to character:

```{r}
vec <- c(1, 2, 3, 4, 5, 6, "7")
vec
```

Types: logical \< raw \< numeric \< complex \< character.

Other group of functios are `as.` to convert vectors:

-   `as.numeric`: a character will be converted to a numeric if it has the syuntax of a number.

    ```{r}
    # The element which no fit as numeric will be NA values by coercion
    as.numeric( c("123.4", "-1234e-2", "4,567", "45. 67", "$12", "45%"))
    ```

-   `as.logical`: Numeric values that are zero become FALSE, otherwise become TRUE. Sometimes numbers that you expect to be zero aren't because of floating-point error.

    ```{r}
    # The third is FALSE because it is outside the range of double precision.
    # The last element 'should' be zero but aren't because floating-point error.
    as.logical( c(123, 5-5, -1e-34, 1e-500, 1- 1/49 * 49) )
    ```

Numeric, non-missing values never produce NA when converted to logical.

## Subsets of Vectors

*subsetting* or *extracting* is to pull out a piece of a vector.

### subscript: numeric

```{r}
# 5-vector
(a <- 101:105)
# extract element number 3
a[3]
```

We can use a numeric expression to compute a subscript but only if we are sure that expression is an integer.

```{r}
# extract the fourth and second element
a[c(4, 2)]
# extract the element corresponding to 3+2 
a[3+2]
```

Negative numbers omit this elements, but you cannot mix negative and positive numbers. Zeros are permited but they are ignored by R.

```{r}
a[-2]
# Omit the first and second element
a[- (1:2) ]
# mix of positive and negative, result an error
a[c(-1, 2)]
```

### Subscript: logical

A logical subscript is a logical vector of the same length as the thing being extracted from. TRUE are returned, FALSE are not.

```{r}
# numeric vector with ages
age <- c(21, 32, 43, 54, 65, 76)
age > 60
```

We can use the last logical vector to extract elements of age, or combining it with other vectors.

```{r}
# Which ages are greater than 60
age[age > 60]

```

```{r}
people <- c("Yoshua", "Mery", "Alex", "John", "Lee", "Cindy")
# To which people corresponds their age greater than 60
people[age > 60]

# Creating a new variable with the previous subscript
age.gt.60 <- age > 60
people[age.gt.60]
```

Errors to avoid:

```{r}
# R convert the logical subscript to numeric
# the extraction produces the first element of the vector two times
people[0 + age.gt.60]

# With the negative sign, R convert again into numeric values
# The extraction drops the first value and rest are returned
people[-age.gt.60]

# This is, probably, the intended form:
# The operator ! to print which values are not greater than 60
people[ !age.gt.60 ]
```

The `which()` function can be used to convert a logical vector into a numeric. It returns the indices of the element that are TRUE.

To find the location of every minimum value in the variable 'y' we can use `which(y == min(y)`. The alternative are `which.min()` and `which.max()` but only select the first index with the minimum or maximum value.

### subscript: names

A name subscript will need to be a character.

```{r}
(vec <- c(a = 201, b = 202, with.space = 203) )

vec["b"]

# Names of 'vec' distinct to 'a'
vec[names(vec) != "a"]
```

### Vector length 0

This usually happens when all of the elements of a logical subscript are FALSE.

```{r}
a
b <- a[a < 99]
b
```

If a zero-length vector is used as the condition in an `if()` statement, an error results:

```{r}
# the sum of a numeric or logical vector of length 0 is itself zero
sum( b + 12345)

if (b < 2) cat("yes\n")
```

### Replacing elements of a vector

If we extract elements, we can use the extraction operation on the left side of an assigment for replacing.

```{r}
a
a[3] <- 203
a
a[a > 104] <- -999
a
```

```{r}
# Replacing using names
names(vec) <- c("a", "b", "c")
vec

cat("\n")

vec["b"] <- 302
vec
```

It is possible too combine two vectors (if the vectors are different types, R convert them) and also assign elements of a vector out past its end.

```{r}
(a <- 101:103)
(b <- -5:-1)
cat("\n")

a[4:8] <- b
a
cat("\n")

# b[6] does not exists, will be filled with NA to add b[7]
b[7] <- 3
b
```

## Missing Data NA

When we try to extract an item that was never present in a vector appears missing values. NA values rule: any computation with an NA itself becomes an NA. With mathematical computations we can use `na.rm = TRUE` argument to compute the result after omitting missing values.

We can use `anyNA()` function to determine whether any of the values are missing (TRUE or FALSE). Also, `is.na()` fuction return TRUE or FALSE for every element in the vector. We can use `where(is.na(vector))`to find the numeric indices of the missing elements.

```{r}
# Creating a vector with missing values
nax <- 101:106
nax[ c(3, 5) ] <- NA
nax
cat("\n")

is.na(nax)
cat("\n")

which(is.na(nax) )

cat("\nMean 'nax' vector: ")
mean(nax)
mean(nax, na.rm=TRUE)

```

We can remove missing values with `vec[!is.na(vec)]` which return non-missing entries, but `na.omit()` function deletes the missing values but also keeps track of where in the vector they used to be. This information is stored in vector's 'attributes':

```{r}
# To return non-missing values:
nax[!is.na(nax)]
cat("\n")

# Storing non missing values in a variable and keeping track of deleted ones
(nay <- na.omit(nax))
attr(nay, "na.action")
attr(nay, "class")
```

We can have a vector 'b' with data and a vector 'a' as index which contain NA values. If we use 'a' as filter, it returns every coincident value and missing value, this behaviour can be changed with `b[!is.na(a) & a == 2]`

```{r}
(b <- 101:104)
(a <- c(1, 2, NA, 4))
cat("\n")

b[a == 2]
cat("\n")

b[!is.na(a) & a == 2]

```

-   `NaN` : Special value, means "Not a Number". It si the result of specific computations such as 0/0. NaN is considered a missing value.
-   `Inf` : Appears when a positive number is accidentally divided by zero. Inf values are not missing.

Inf + NA = NA\
NaN + NA = NaN

We generally wanto to identify any of these values: the function `is.finite()` produces TRUE for numbers that are neither NA nor NaN nor Inf. It serves as a check on valid values. The command `all(is.finite(vector) )` is to see a numeric vector elements which are not special values.

-   `NULL` : is an object with zero length, no contents, no class. It often arise trying to access an element which does not exist. The function `is.null()` is for testing NULL values. If you index using a NULL value the result will be a vector of length 0.

## The `Table( )` function

`Table()` produce a table returning for each unique value the number of times that value appears.

```{r}
vec <- rep ( c("red", "blue", NA, "green"), c(4, 2, 1, 3) )
vec
cat("\n")

table(vec)
```

`table()` arguments:

-   `useNA =`

    -   `"no"` : default option. Exclude NA values.
    -   `"ifany"` : show an entry for NA if there are any.
    -   `"always"` : show an entry for NA whether there are any NA values or not.

-   `exclude =`

    -   `c(NA, NaN)` : default option.

    -   We can add a value of the vector to exclude, also we can pass `NULL`.

```{r}
table(vec, useNA = "always")
cat("\n")

table(vec, exclude="green")
```

Also, we can pass to `table()` function two vectors to create a two-way table (cross-tabulation). in R a two-way table is treated the same as a matrix.

```{r}
vec2 <- rep ( c("north", "south", "east", "west"), c(2, 3, 2, 3) )
table(vec,vec2, useNA="ifany")
```

A three and higher-way tables are produced when you pass three or more equal-length vectors.

For very large vectors, the `data.table()` functino in the `data.table` package may prove more efficient than `table()`.

The `xtabs()` function is useful for creating more complex tables.

### Operating on tables

-   `prop.table()` : passing a variable with table assigned produces the proportions of the total counts in the table by cell (or row, or column). The second argument references 1 to rows, or 2 to columns.

```{r}
year <- rep (2015:2017, each=5)
market <- c("a", "a", "b", "a", "b", "b", "b", "a", "b", 
            "b", "a", "b", "a", "b", "a")
cost <- c(64, 87, 71, 79, 79, 91, 86, 92, NA,
          55, 37, 41, 60, 66, 82)

# assign a table with the vectors we want to 'tab'
tab <- table(market, year)
tab
cat("\n")

# proportions along rows
prop.table(tab)
cat("\n")

# proportions throwout columns
prop.table(tab, 2)

```

-   `margin.table()` : produce the marginals totals from a table.

-   `addmargins()` : to a given table incorporates those totals producing a new row and column by default. Passing as second argument 1 or 2, you can specified if only wants rows or columns.

```{r}
cat("margin.table function for columns:\n")
margin.table(tab, 2)

cat("\naddmargins function in the table: \n")
addmargins(tab)
```

-   `tapply()` : the arguments are, first the vector where perform the computation, second the vector with the index to group, and then the function to apply. To group with more than one vector (index) we can use a `list()`.

```{r}
cat("There are NA in cost? ")
anyNA(cost)
cat("\n")

tapply (cost, year, min, na.rm=TRUE)
cat("\n")

tapply (cost, list(market, year), mean, na.rm = TRUE)
```

It is posible to use with tapply() custom fuctions, as an example, for (x) return the sum of the squares of each entry of x:

```{r}
tapply (cost, list(market, year),
        function (x) sum (x^2, na.rm = TRUE))
```

## Other Actions on Vectors

### Rounding

-   `round()` : to round a number with specific amount of decimals. Passing a negative number as second argument will round the nearest power of 10.

-   `signif()` : retain a specific number of digits.

-   `trunc()` : discards the decimal part returning an integer.

-   `floor()` ; `ceiling()` : round to the next lower or higher integer respectively.

```{r}
(dec <- 123.4567)

cat("\nRound function to 3 decimals: \n")
round(dec, 3)

cat("\nRound function (-1) to nearest power of 10: \n")
round(dec, -1)

cat("\nSignif function to 4 numbers: \n")
signif(dec, 4)

cat("\nTrunc function: \n")
trunc(dec)

cat("\nFloor function to round to the lower integer: \n")
floor(dec)

cat("\nRound function to round to the higher integer: \n")
ceiling(dec)
```

### Sorting and Ordering

-   `sort()` : sorting from smallest to largest. It will drop NA and NaN values by default.

    -   `decreasing=TRUE` will reverse the order.
    -   `na.last` will add NA values, TRUE at the end and FALSE at the beginning.

-   `order()` : returns the indices which can be used to sort a vector.

    -   `na.last` as TRUE by default. TRUE at the end and FALSE at the beginning.

```{r}
people
(scores <- c(123, 456, 789, 456, 654, 987))

cat("\nSorting 'people' by their scores (descending): \n")
people[order(scores, decreasing=TRUE)]

cat("\nOrdering people by their scores, and in case 
    of a tie using their names alphabetically.: \n")
people[order(scores, people[1:6])]
```

### Vector as Sets

To find values that overlap between two vectors we can use `%in%` function. For example, we can use a command `a %in% b` which will return a vector the same length as 'a' with a logical indicator whether each element is foundin 'b'. Witch `table(a %in% b)` we get the number of element in 'a' that were not found in 'b'.

```{r}
# Looking for which letter is in 'letters':
c("g", "5", "b", "J", "!") %in% letters
cat("\n")

table (c("g", "5", "b", "J", "!") %in% letters)
cat("\n")

which(c("g", "5", "b", "J", "!") %in% letters)
```

-   `union()` : returns the elements in either passed vectors
-   `intersect()` : returns the elements which are in both passed vectors
-   `setdiff()` : returns the elements of 'a' not present in 'b'

```{r}
cat("Union 'a' and 'b':\n")
union (c("g", "5", "b", "J", "!"), letters)
cat("\n")

cat("Intersect 'a' with 'b':\n")
intersect (c("g", "5", "b", "J", "!"), letters) 
cat("\n")

cat("Defferent elemenets of 'a' in 'b':\n")
setdiff (c("g", "5", "b", "J", "!"), letters) 
```

## Duplicates

-   `anyDuplicated()` : returns the duplicated values in a vector

-   `unique()` : returns the distinct values, including NA and NaN.

-   `duplicated(`) : returns a logical vector with TRUE per duplicated value (not the first value).

    -   `fromLast=TRUE` reads from the end to the beginning. Using union() you can combine `fromLast=TRUE` and `fromLast=FALSE` to identify all duplicates.

```{r}
let <- c(letters, c("j", "j", "x"))

cat("Duplicates?\n")
let[duplicated(let)]

cat("\n")
(tab <- table (let))

cat("\n")
tab[which (tab != 1)]

cat("\n")
names (tab)[tab != 1]

cat("\n")
table (table (let))
```

Matching is identify where in a vector we can find the values in another vector. The function `match()` is a more powerful version of `%in%`.

-   `match()` : given two vectors returns where the element from 'a' is in 'b'. By default returns NA for no matches, we can change this with `nomatch=0` argument.

```{r}
names1 <- c("Jensen", "Chang", "Johnson", "Lopez", "McNamara", "Reese")
names2 <- c("Lopez", "Ruth", "Nakagawa", "Jensen", "Mays")

match(names1, names2)

cat("\n")
names2[match(names1, names2, nomatch=0)]
```

The 'Run length enconding' function is rle() which returns the number of repetitions and length.

```{r}
rle( c("a", "b", "b", "a", "c", "c", "c", "a", "a"))
```

The previous output show, with length 1 value 'a' followerd by 'b' with length 2, again 'a' length 1 and then 'c' with length 3, to finish with 'a' twice.

## Summary

### Conversions

-   Converting character to numeric produces NA for things that aren’t numbers, like the character strings "TRUE" or "\$199.99".
-   Converting character to logical produces NA for any string that isn’t "TRUE", "True", "true", "T", "FALSE", "False", "false" or "F".
-   Converting numeric to logical produces FALSE for a zero and TRUE for any non-zero entry (and watch out for floating-point error here).

### Subscripts

-   A logical subscript returns the values that match up with its TRUE entries.
-   A numeric subscript returns the values specified in the subscript.
-   character subscript will extract, from a named vector, elements whose names are present in the subscript.

# R Data: Other Structures

## Matrices

Essentially is a vector two-dimensional like a rectangle. Every element of a matrix needs to be of the same type (numeric, logical or character).

A matrix is filled column by column.

Using `length()` we get the total number of elements in the matrix, and using `dim()` we get the dimension as number of rows and columns.

-   `cbind()` : combines a set of vectors into a matrix column by column.

-   `rbind()` : combines a set of vectors into a matrix row by row.

If the vectors to combine have unequal length, R will recycle.

With matrix in the same way as vectors we can do arithmetic operations, that will be element by element. Also, `t(A)` transposes a matrix, and `solve()` inverts a matrix.

To extract and assign new values to elements the process is similar to a vector but now we have to pass two coordinates:

```{r}
a <- matrix(101:115, nrow=5, ncol=3)
a
cat("\n")

a[1,2]

cat("\n")
a[-2,]

cat("\nObtaining row 4 and 2, and cols 3 and 1, in that order: \n")
a[c(4,2), c(3,1)]
```

To create a vector from a matrix we can use `c()`, it will use the first column, then the second and so on. To extract data row by row, we can use `t()` to transpose the matrix first like `c(t(a))`.

```{r}
c(a)
cat("\n")

t(a)

cat("\n")
c(t(a))
```

If we ask to a matrix for one column we'll get a vector, because dimensions of length 1 are usually dropped by default. We can use drop=FALSE argument to prevent that.

```{r}
a[,2]

cat("\n")
a[,2, drop=FALSE]
```

### Row and Column Names

With `dimnames()` we get rows and columns names. `rownames()` and `colnames()` to get rows and columns names respectively. As well as with `names()` and vectors, we can asign names to columns and rows with these functions.

```{r}
year <- rep (2015:2017, each = 5)
market <- c(2, 2, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 2, 3, 2)

(tbl <- table (market, year))

cat("\nCollaing to colnames(): \n")
colnames(tbl)

cat("\nAssigning new names to columns: \n")
colnames(tbl) <- c("Y15", "Y16", "Y17")
tbl
```

Just like before, we can call for the column name or row identifier to get them:

```{r}
tbl[,"Y15"]

cat("\n")
tbl["3",]
```

### Applying Functions

Built in functions which works across columns or rows: `colSums(), rowSums(), colMeans(), rowMeans()`.

-   `apply()` : Useful to apply a custom function.

    -   first argument, the matrix to which apply the function.

    -   The direction, 1 for across rows, 2 for down columns.

    -   The function to be applied.

```{r}
a

cat("\n")
rowSums(a)

cat("\n")
apply(a, 1, sum, na.rm=TRUE)

cat("\n")
apply(a, 1, function (x) sum (x))
```

We can guet a matrix result for the `apply()` function. If we compute across rows, sometimes will change the shape, we can use `t()` to prevent that.

```{r}
apply(a, 2, range)

cat("\n")
t( apply(a, 1, range) )
```

When we are looking for specific values we can get vectors with different lengths, in that case R returns a list.

```{r}
cat("Getting elements location where the value is greater than 109:\n")
apply(a, 2, function (x) which (x > 109))
```

### Missing Values

The function apply() is very useful to count the number of missing values. Next, let's create a matrix using a semicolon to pass multiple commands in one line, also the multiple assigment operation to assign several things at once:

```{r}
a <- matrix(101:115, 5, 3); a[5, 3] <- a[3, 1] <- NA
a

cat("\nSum of NA in each column: \n")
apply(a, 2, function (x) sum (is.na(x)))
```

Tracking NA values with `which()` to identify the position on the vector will return a number of the position for each NA. However, using `arr.ind=TRUE` argument we'll obtain the coordinates:

```{r}
which(is.na(a))

cat("\n")
which(is.na(a), arr.ind=TRUE)
```

### Matrix Subscripts

With `which()` as a subscript we have the possibility to extract specific elements.

```{r}
b <- matrix (1:20, nrow=4, byrow=T)
b <- cbind(b, c(3, 2, 0, 5))
colnames(b) <- c("P1", "P2", "P3", "P4", "P5", "Use")
rownames(b) <- c("Spring", "Summer", "Fall", "Winter")
b
```

Given the previous matrix, the Use column specify which element of the row we want get. To generate this coordinates, we are going to generate a matrix, the first column will be the number of rows and the second column 'Use'. Then we can pass that matrix as a subscript to 'b' and extract the elements.

```{r}
(filt <- cbind(1:nrow(b), b[, "Use"]) )

cat("\n")
b[filt]

```

### Higher-way Arrays

A matrix with three or more ways is called Array in R. We can encounter this while constructing a higher way `table()`:

```{r}
who <- rep( c("Mery", "Kelly"), c(2, 6))
when <- rep( c("AM", "PM"), 4)
worked <- c(T, T, F, T, F, T, F, T)
sch <- table(who, when, worked)
sch
```

The function `aperm()` is like `t()` but for higher-way arrays. Also we can use `c()` to produce a vector, and `apply()` or `prop.table()` works too.

## Lists

A list can have vector or diferent types and sizes, also might include matrices, lists or other R objects. Usually a list is returned by a modeling function in R but we can create a list with `list()`:

```{r}
ali <- list( alpha = 1:4, beta = "yes", delta = log, 69)
ali
```

-   `split()` : divides a vector into pieces according to the value of another vector. Returns a list. Missing values in the second vector passed will be dropped.

```{r}
age <- c(31, 33, 42, 54, 65, 74, 24)
gender <- c("F", "M", "F", "M", "M", "F", "F")

cat("Split age by gender:\n")
split(age, gender)

cat("\nSplit ages when age is greater than 60\n")
split(age, age > 60)
```

We can see with `length()` function the number of elements inside a list, and with `lengths()` function the length of each element.

```{r}
length( split(age, gender) )

cat("\nLengths: \n")
lengths( split(age, gender) )
```

The `str()` command gives a description of every element on the list:

```{r}
str(ali)

cat("\n")
class(ali)
```

### Excracting from list

Working with a list, the rule says *single backets produce a list, while double backets and dollar signs extract contents.*

```{r}
cat("Extracting the content of element 4 as a vector: \n")
ali[[4]]

cat("\nExtracting the element 1 as a list: \n")
ali[1]

cat("\nExtracting inside alpha the elements 2 and 4: \n")
ali$alpha[c(F, T, F, T)] 


```

The function `names()` also works with lists returning the names of each element and "" if the element no have name. We can assign names with it too.

When we extract an element from a list with dollar sign, we do not need to know the complete name, it is enough if it's unambiguous:

```{r}
ali$a

cat("\n")
ali$de
```

To assign new values to an element we need the full name, otherwise will be creating a new ítem.

```{r}
ali$delta <- c(T, F, F, T)
str(ali)
```

To remove an element from a list we can assign a NULL value:

```{r}
ali$beta <- NULL
str(ali)
```

-   `unlist()` : try to turn the list into a vector:

```{r}
unlist(ali)
```

Using dimnames() function we can see the names from a matrix as list format and also we can asign names:

```{r}
b
cat("\n")
dimnames(b)

dimnames(b)[[1]][3] <- "Autumn"
cat("\n")
b

```

An important list returned from a function is the list from `options()` which contain elements describing things like number of digits to be displayed, scientific notation, the editor... With `names(options())` we can see the names of the current options.

```{r}
names(options())[3:15]
```

## Data Frames

A data.frame is a list of vector with the same length which can be arrayed in a matrix-like rectangle. Each vector in the list will be the columns. To construct a data frame we use `data.frame()` function.

```{r}
df <- data.frame (
    Who = letters[1:5],
    Cost = c(3, 2, 11, 4, 0),
    Paid = c(F, T, F, T, T),
    stringsAsFactors=FALSE
)
row.names(df) <- as.character (row.names(df))
df
```

A data frame must have a column and row names, if they are not assigned R will create them. Also R ensure that column names are valid and not duplicated. For columns we can use `colnames()` or `dimnames()` to assign it, or `names()` with a list. For row names we have `row.names()` or `rownames()` functions.

By default the `data.frame()` function turns character vectors into factors but rarely we want it in data cleaning. We can chage this with `stringAsFactors=FALSE` argument.

-   `head()` : return the first six rows of a given dataframe. Second argument is n=6 to specify a number of rows. A negative number returns the last n rows.

-   `tail()` : return the last six rows of a given dataframe. Second argument is n=6 to specify a number of rows.

-   `str()` : compact representation of the data frame with data type per column.

-   `dim()` : returns the dimension, number of rows and columns.

-   `summary()` : returns a brief description of each column.

### Missing Values

Because a data frame can have differnt classes (data types) in its colums, the missing values can be of different classes too. A numeric vector will have numeric NA which is different to logical NA from a logical vector.

-   `is.na()` : returns a logical matrix showing which elements are missing.

-   `anyNA()` : returns TRUE or FALSE to the question There are missing values?

-   `na.omit()` : omit the observations (rows) of the data frame in which one or more elements is missing. Also keeps a track, we can see the deleted observations with `attr(df, "na.action") ; attr(df, "class")`.

Extract and Assignment

With data frames we can use both matrix and list styles of subsetting operations. In data frames when we select a row returns a data frame because can store different types of data. Selecting a column will produce a vector.

Using a doble bracket or a dollar sign will produce a vector. Using the name produce a data frame.

```{r}
df[4,]

f <- df$Paid
df[f,]

df[(df["Paid"] == F),]

df["Cost"]
```

To extract a vector from a dataframe's column:

```{r}
df[[2]]

cat("\n")
df[["Cost"]]

cat("\n")
df[["Co", exact=FALSE]]
```

Passing `drop=FALSE` argument we avoid to extract a vector:

```{r}
df[, c("Who", "Paid")]

df[, "Who"]

df[, "Who", drop=FALSE]
```

To delete a column we can asign NULL to that column: `df$Paid <- NULL`

In a data frame or list if we pass a subscript for unexistance row wil produce one row with NA values. Sometimes happens when we delete a row and a program or ourselfs try to access to that row by name.

## Operating on Lists and Data Frames

If we try to use `apply()` in a data frame, the function will convert it to a matrix, and the whole matrix is of the same data type. Also, we cannot use `apply()` to a list because does not have dimensions.

-   `lapply()` : returns a list
-   `sapply()` : runs `lapply()` and tries to make the output into a vector or a matrix. But if the return have different lengths, it will need to return a list. If it try to return items with diferent types, will convert these to a common type, then its better in these case use `lapply()`.

```{r}
sapply (df, class)
```

### Spliy, Apply, Combine

First the data is split, then a function is applied to each piece, and the results recombined. The function `tapply()` do exactly that, but also we can use `split()` and `sapply()` or `lapply()`.

```{r}
df2 <- data.frame (
    Age = c(35, 24, 42, 63, 56, 66),
    Spouse = c(31, 36, 40, 59, 60, 60),
    Gender = c("F", "F", "M", "F", "M", "M")
)
split (df2$Age, df2$Gender)

cat("\nUsing sapply() to obtain the mean by gender :\n")
sapply (split (df2$Age, df2$Gender), mean)
```

Above, `split()` divides Gender with Age values, then `sapply()` use `mean()` function to each part and returns a vector with the results (is the recombine). Let's see `tapply()` :

```{r}
round( tapply(df2$Age, df2$Gender, mean), 3 )
```

We can use `split()` on a data frame unlike `tapply()`, doing that the data frame will be divided and then we can use `sapply()` or `lapply()` to each part.

```{r}
split (df2, df2$Gender)

cat("\nSummary differencing Gender: \n")
lapply ( split (df2, df2$Gender), summary )
```

```{r}
cat("\nLet's see what happens with sapply: \n")
sapply ( split (df2, df2$Gender), summary )
```

The previous `sapply()` will try to construct a vector or matrix converting everything to a common type.

A function to produce the same result is `by()` but without letting yyou save the list. It will prerforms the `summary()` operation on each column, broken down by gender:

```{r}
by ( df2, df2$Gender, summary )
```

Sometimes the task split, apply and combine can be performed altogether, but but other times might require separare functions. Packages like `dplyr` for data frames or `plyr` for lists and arrays. Both are intended to be fast and efficient and to permit parrallel computation.

### All-Numeric Data Frames
