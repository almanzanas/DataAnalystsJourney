blanks[nzchar(blanks)]
blanks <- c (" ", " ", "", "   ", "", "2016", "", " 2016", "2016", "   ")
length(blanks)
table(blanks)
names(table(blanks))
nzchar(blanks)
noblanks <- trimws(blanks)
blanks[nzchar(noblanks)]
blanks <- c (" ", " ", "", "   ", "", "2016", "", " 2016", "2016", "   ")
length(blanks)
table(blanks)
names(table(blanks))
nzchar(blanks)
noblanks <- trimws(blanks)
blanks[nzchar(noblanks)]
names(table(noblanks))
blanks <- c (" ", " ", "", "   ", "", "2016", "", " 2016", "2016", "   ")
length(blanks)
table(blanks)
names(table(blanks))
nzchar(blanks)
# Removing white spaces located in the start or end of a element:
noblanks <- trimws(blanks)
table(noblanks)
names(table(noblanks))
dt1 <- "2017-02-03"
# Extracting the year
substring(dt1, 1, 4)
# Extracting day and month (last five characters)
substring (nchar(dt) - 4)
dt1 <- "2017-02-03"
# Extracting the year
substring(dt1, 1, 4)
# Extracting day and month (last five characters)
substring (dt1, nchar(dt1) - 4)
nchar(dt1)
nchar(dt1) -4
substring(dt1, 6)
substring(dt1, 1, 5)
substring(dt1, 1:nchar(dt1), 1:nchar(dt1) )
substring(dt1, 1:nchar(dt1), 1:nchar(dt1) )
strsplit(dt1)
?strsplit
substring(dt1, 1:nchar(dt1), 1:nchar(dt1) )
strsplit(dt1, split = "")
substring(dt1, 1:nchar(dt1), 1:nchar(dt1) )
strsplit(dt1, split = NULL)
month.name
weekdays.name
weekdays
holid <- month.name
substring (holid[6:8], nchar(holid[6:8]) ) <- "_vac"
holid[5:9]
holid <- month.name
substring (holid[6:8], nchar(holid[6:8]) - 3 ) <- "_vac"
holid[5:9]
holid <- month.name
substring (holid[6:8], nchar(holid[6:8]) - 1 ) <- "VA"
holid[5:9]
holid <- month.name
substring (holid[6:8], nchar(holid[6:8]) - 0 ) <- "9"
holid[5:9]
holid <- month.name
substring (holid[6:8], nchar(holid[6:8] + 3) - 0 ) <- "9"
holid <- month.name
substring (holid[6:8], nchar(holid[6:8]) - 0 ) <- "9"
holid[5:9]
?casefold
.simpleCap <- function(x) {
s <- strsplit(x, " ")[[1]]
paste(toupper(substring(s, 1, 1)), substring(s, 2),
sep = "", collapse = " ")
}
.simpleCap("the quick red fox jumps over the lazy brown dog")
format ( c(12.23, 1234.45678, 0, 10.000) )
format ( c(12.23, 1234.45678, 0, 10.000), big.mark="," )
format ( c(12.23, 1234.45678, 0, 10.000),
digits = 6, nsmall = 2, zero.print = FALSE, width = 2)
# 8 characters, 2 decimals.
sprintf ( "%8.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%08.2f", 1230.456789 )
sprintf ( "% 8.2f", 1230.456789 )
sprintf ( "%+8.2f", 1230.456789 )
sprintf ( "%8.2d", 1230.456789 )
# 8 characters, 2 decimals.
sprintf ( "%8.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%08.2f", 1230.456789 )
sprintf ( "% 8.2f", 1230.456789 )
sprintf ( "%+8.2f", 1230.456789 )
sprintf ( "%8d", 1230.456789 )
?sprintf
# 8 characters, 2 decimals.
sprintf ( "%9.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%09.2f", 1230.456789 )
sprintf ( "% 9.2f", 1230.456789 )
sprintf ( "%+8.2f", 1230.456789 )
sprintf ( "%i", 1230.456789 )
# 8 characters, 2 decimals.
sprintf ( "%9.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%09.2f", 1230.456789 )
sprintf ( "% 9.2f", 1230.456789 )
sprintf ( "%+9.2f", 1230.456789 )
sprintf ( "%-9.2f", 1230.456789 )
sprintf ( "%8.2g", 1230.456789 )
# 8 characters, 2 decimals.
sprintf ( "%9.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%09.2f", 1230.456789 )
sprintf ( "% 9.2f", 1230.456789 )
sprintf ( "%+9.2f", 1230.456789 )
sprintf ( "%-9.2f", 1230.456789 )
sprintf ( "%9.2g", 1230.456789 )
# 8 characters, 2 decimals.
sprintf ( "%9.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%09.2f", 1230.456789 )
# Like the previous one but with spaces
sprintf ( "% 9.2f", 1230.456789 )
# Always a simbol leading the number
sprintf ( "%+9.2f", 1230.456789 )
# Left Justified
sprintf ( "%-9.2f", 1230.456789 )
#
sprintf ( "%9.4g", 1230.456789 )
# 8 characters, 2 decimals.
sprintf ( "%9.2f", 1230.456789 )
# 0 leading the character to fill with 0 until 8 characters.
sprintf ( "%09.2f", 1230.456789 )
# Like the previous one but with spaces
sprintf ( "% 9.2f", 1230.456789 )
# Always a simbol leading the number
sprintf ( "%+9.2f", 1230.456789 )
# Left Justified
sprintf ( "%-9.2f", 1230.456789 )
#
sprintf ( "%9.3g", 1230.456789 )
costs <- c(3, 22, 456.32, 89340.4235, 1230045605.959)
sprintf ( "I spent $%d in %s", costs, month.name[2:6] )
costs <- c(3, 22, 456.32, 89340.4235, 1230045605.959)
sprintf ( "I spent $%.0f in %s", costs, month.name[2:6] )
bigs <- max (nchar (sprintf ("%.2f", costs) ) )
sprintf ("spent $%*.2f in %s",
bigs, costs, month.name[2:6] )
bigs <- max (nchar (sprintf ("%.2f", costs) ) )
sprintf ("spent $%*.2f in %s \n",
bigs, costs, month.name[2:6] )
bigs <- max (nchar (sprintf ("%.2f", costs) ) )
sprintf ("spent $%*.2f in %s",
bigs, costs, month.name[2:6] )
sprintf ("%03d", 1:15 )
100000
c( 1, 100000 )
c( 1, 100000, 123456 )
as.integer (1000000 + 1 )
format ( 1000000, scientific=FALSE)
vec <- c(1, 5, 7, 2, 8, 9, 3, 4, 10)
as.character (cut (vec, c(1, 4, 7, 10), include.lowest=TRUE, right=FALSE) )
# Generating random numbers
set.seed(168)
rand.vec <- rnorm(1000)
# cut() with breaks=5 of equal width
table (cut (rand.vec, breaks=5) )
# Using quantile() to create bins with equal number of observations
table (cut (rand.vec, quantile(rand.vec) ) )
?cut
?quantile
# Generating random numbers
set.seed(168)
rand.vec <- rnorm(1000)
# cut() with breaks=5 of equal width
table (cut (rand.vec, breaks=5) )
# Using quantile() to create bins with equal number of observations
table (cut (rand.vec, quantile(rand.vec) ) )
# quantile() with probs argument to create 5 bins instead of 2
table (cut (rand.vec,
quantile(rand.vec, probs=seq(0, 1, 0.2) ),
include.lowest = TRUE ) )
paste("a", "b", "c")
paste0( 1 == 2, 1 + 2)
paste0("Arg", LETTERS[3:7], sep=".")
paste(letters[1:5], LETTERS[5:1], collapse = "\n")
paste("a", "b", "c")
paste0( 1 == 2, 1 + 2)
paste0("Arg", sep=".", LETTERS[3:7])
paste(letters[1:5], LETTERS[5:1], collapse = "")
?paste
paste("a", "b", "c")
paste0( 1 == 2, 1 + 2)
paste0("Arg", sep=".", LETTERS[3:7])
paste(letters[1:5], LETTERS[5:1], collapse = ", ")
head (
outer (month.abb, 2016:2018, paste, sep = "." ), 5
)
monseq <- outer (month.abb, 2016:2018, paste, sep = "." )
newnam <- c("ID", paste0 ("Bal.", monseq) )
sample(newnam, 5)
head (
outer (month.abb, 2016:2018, paste, sep = "." ), 5
)
# Creating the month sequence for each year
monseq <- outer (month.abb, 2016:2018, paste, sep = "." )
# Creating the column names
newnam <- c("ID",
paste0 ("Bal.", monseq),
paste0 ("Pay.", monseq) )
sample(newnam, 5)
head (
outer (month.abb, 2021:2023, paste, sep = "." ), 5
)
# Creating the month sequence for each year
monseq <- outer (month.abb, 2021:2023, paste, sep = "." )
# Creating the column names
newnam <- c("ID",
paste0 ("Bal.", monseq),
paste0 ("Pay.", monseq) )
sample(newnam, 5)
# Alternative maybe more eficient but more tedious
p1 <- rep (c("Bal", "Pay"), 12 * 3)
# Each month 2 times for Bal and Pay, and then 3 times for the years
p2 <- rep ( rep(month.abb, each = 2), 3 )
# Each year two times, for Bal and Pay
p3 <- rep (2021:2023, each = 24)
newnam <- c("ID", paste(p1, p2, p3, sep=".") )
sample(newnam, 5)
names.df <- expand.grid (c("Bal", "Pay"),
c(2021:2023),
month.abb,
stringAsFactors=FALSE)
sample(names.df, 5)
names.df <- expand.grid (c("Bal", "Pay"),
c(2021:2023),
month.abb,
stringAsFactors=FALSE)
names.df
names.df <- expand.grid (c("Bal", "Pay"),
month.abb,
c(2021:2023) )
names.df
names.df <- expand.grid (c("Bal", "Pay"),
month.abb,
c(2021:2023) )
names.df
newnam <- paste ( names.df[["Var1"]],
names.df[["Var2"]],
names.df[["Var3"]],
sep = "." )
sample(newnam, 5)
names.df <- expand.grid (c("Bal", "Pay"),
month.abb,
c(2021:2023) )
newnam <- paste ( names.df[["Var1"]],
names.df[["Var2"]],
names.df[["Var3"]],
sep = "." )
sample(newnam, 5)
?expand.grid
gc()
set.seed(168)
rnd.dts <- as.Date (sample (0:730, size = 600), origin = "2021-01-01")
table (quarters (rnd.dts) )
talbe ( paste0 (format (rnd.dts, "%Y"), ".", quarters(rnd.dts) ) )
set.seed(168)
rnd.dts <- as.Date (sample (0:730, size = 600), origin = "2021-01-01")
table (quarters (rnd.dts) )
table ( paste0 (format (rnd.dts, "%Y"), ".", quarters(rnd.dts) ) )
?tapply
ym.order <- paste0 (2021:2023, ".", month.abb )
ym.tbl <- table (format(rnd.dts, "%Y.%b") )
ym.tbl[ym.order][3:7]
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B") )
ym.tbl[ym.order][3:7]
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B"), na.rm=TRUE )
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B") )
ym.tbl[ym.order][3:7]
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B") )
ym.tbl[ym.order][1:5]
list.files (full.names =TRUE)
paste (getwd(), list.files(), sep="/")
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".[0-3]?[0-9].*(", mo, ").*[1-2][0-9]{3}")
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".[0-3]?[0-9].*(", or.mon, ").*[1-2][0-9]{3}")
grep (re, dt, value = TRUE )
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".*[0-3]?[0-9].*(", or.mon, ").*[1-2][0-9]{3}")
grep (re, dt, value = TRUE )
dt <- c(
"Balance due 16 Jun or earlier in 2017",
"26 Aug or any day in 3021",
"'76 Trombones' marched in a 1962 film",
"4 Apr 2018", "9Aug2006",
"99 Voters May Register in 20188"
)
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".*[0-3]?[0-9].*(", or.mon, ").*[1-2][0-9]{3}")
grep (re, dt, value = TRUE )
pain <- c("c:\\temp", "/bin/u", "$5", "\n", "2 backs: \\\\")
grep ("$", pain)
grep ("\\$", pain, value=TRUE)
grep ("\\\\", pain, value=TRUE)
grep ("\\", pain, value=TRUE, fixed=TRUE)
# Looking for any slashes:
grep ("\\|/", pain, value=TRUE, fixed=FALSE)
?grep
?regex
dt
# looking for a word with an integer:
(regout <- regexpr( "\\<\\d+\\>", dt ) )
attr(,"match.legth")
dt
# looking for a word with an integer:
(regout <- regexpr( "\\<\\d+\\>", dt ) )
attr(,"match.legth")
regmatches (dt, regout)
( gout <- gregexpr ("\\<\\d+\\>", dt) )
regmatches (dt, gout)
# Creating a matrix with the return of regmatches
matrix (as.numeric (unlist (regmatches (dt, gout) ) ) )
gout <- gregexpr ("\\<\\d+\\>", dt)
regmatches (dt, gout)
# Creating a matrix with the return of regmatches
matrix (as.numeric (unlist (regmatches (dt, gout) ) ), ncol=2, byrow=T )
?do.call
do.call (regmatches, dt, gout)
do.call (regmatches, gout, dt)
dt |> do.call (regmatches, gout)
?regmatches
do.call (regmatches, gout, x=dt)
do.call (regmatches, list(dt, gout) )
?rbind
bros <- c("Isaac Asimov", "Leon Tolstoi", "Virginia Woldf", "Brandon Sanderson")
# Changing the name order with backreferences:
sub ("([[:alpha:]]+) ([[:alpha:]]+)", "\\2, \\1", bros)
bros <- c("Isaac Asimov", "Leon Tolstoi", "Virginia Wolf", "Brandon Sanderson")
# Changing the name order with backreferences:
sub ("([[:alpha:]]+) ([[:alpha:]]+)", "\\2, \\1", bros)
keys <- c("CA-2017-04-02-66J-44",
"MI-2017-07-17-41H-72",
"CA-2017-08-24-Missing-378")
(key.list <- strsplit (keys, "-") )
matrix ( unlist (key.list), ncol = 6, byrow = TRUE )
install.packages("ymlthis")
ymlthis:::launch_yaml_addin()
gsub ( "^ *| *$", "", c("  Text Spaces ", "Trailing    ",
"None", "     Leading" ) )
as.numeric ( gsub ("(^[^0-9.]|,)|(,|[^[:digit:].]$",
"", c("$12,345.67", "98,765.43€") ) )
as.numeric ( gsub ("(^[^0-9.]|,)|(,|[^[:digit:].]$)",
"", c("$12,345.67", "98,765.43€") ) )
html <- c('
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ejemplo de HTML</title>
</head>
<body>
<h1>Bienvenido a mi página web</h1>
<p>Este es un <strong>ejemplo</strong> de un párrafo con <em>texto en cursiva</em> y <strong>texto en negrita</strong>.</p>
<ul>
<li>Elemento de lista 1</li>
<li>Elemento de lista 2</li>
<li>Elemento de lista 3</li>
</ul>
<a href="https://www.ejemplo.com">Visita nuestro sitio web</a>
</body>
</html>
')
gsub ( "<.*?>", "", html)
html <- c('
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ejemplo de HTML</title>
</head>
<body>
<h1>Bienvenido a mi página web</h1>
<p>Este es un <strong>ejemplo</strong> de un párrafo con <em>texto en cursiva</em> y <strong>texto en negrita</strong>.</p>
<ul>
<li>Elemento de lista 1</li>
<li>Elemento de lista 2</li>
<li>Elemento de lista 3</li>
</ul>
<a href="https://www.ejemplo.com">Visita nuestro sitio web</a>
</body>
</html>
')
no.html <- gsub ( "<.*?>", "", html)
gsub ("\\n", "", no.html)
cat(no.html)
# Linux to Windows
gsub ("/", "\\\\", "/usr/local/bin")
# Windows to Linux
gsub("\\\\", "/", "\\usr\\local\\bin")
gsub("\\", "/", "\\usr\\local\\bin", fixed = TRUE)
(yogi <- "It's d\xe9j\xe0 vu all over again.")
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("‘a", yogi) )
yogi <- "It's d\xe9j\xe0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
?iconv
yogi <- "It's d\xe9j\xe0 vu all over again."
cat(yogi)
yogi.utf8 <- iconv (yogi, latin1, utf8)
yogi <- "It's d\Ue9j\Ue0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
yogi <- "It's d\Ue9j\Ue0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
yogi.lat <- "It's d\\xe9j\\xe0 vu all over again."
Encoding (yogi.utf)
Encoding (yogi.lat)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
yogi.lat <- "It's d\\xe9j\\xe0 vu all over again." |> iconv("latin1", "UTF-8")
Encoding (yogi.utf)
Encoding (yogi.lat)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
Encoding (yogi.utf)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
Encoding (yogi.utf)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.utf), regexpr ("à", yogi.utf) )
data.frame (a = "\U4e2d\U56fd", stringsAsFactors = FALSE)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
lables(cols.fac)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac)["blue"]
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac["blue"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac["red"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
table(cols.fac[cols.fac != "red"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
table(cols.fac[cols.fac != "red"])
levels(cols.fac)
levels(cols.fac)[2] <- "yellow"
levels(cols.fac)
factor (cols.fac, levels = c("red", "blue", "yellow") )
cols.fac
factor (cols.fac, levels = c("red", "blue", "yellow") )
ind <- factor ( c(3, 4, 6, 33, 66, 77) )
src <- 101:199
# as.numeric will convert the vector elements into its assigned integers, not the levels.
as.numeric(ind)
ind <- factor ( c(33, 4, 66, 3, 6, 77) )
src <- 101:199
# as.numeric will convert the vector elements into its assigned integers, not the levels.
as.numeric(ind)
ind
# Correct way, looking for that indices into 'src' vector:
src[as.numeric (as.character (ind) )]
gender <- as.factor(c("F", "F", "M", "F", "M", "F", "M") )
gender
as.numeric(gender) - 1
mis.fac <- as.factor(c("F", NA, "M", "F", NA, "F", "M") )
mis.fac
mis.fac <- as.character(mis.fac)
mis.fac[is.na (mis.fac)] <- "missing"
( mis.fac <- as.factor(mis.fac) )
for (i in 1:24)
assign (paste0 (LETTERS[i], month.abb), i, pos = 1 )
let.mon <- ls (pattern = "^[A-Z]{2}?[a-z]{2}?")
let.mon[3:6]
sapply (let.mon, function(i) object.size(get(i)))
remove (list = grep ("^[A-Z]{2}?[a-z]{2}?", ls(), value = T ) )
for (i in 1:24)
assign (paste0 (LETTERS[i], (month.abb+month.abb)[i]), i, pos = 1 )
for (i in 1:24)
assign (paste0 (LETTERS[i], c(month.abb,month.abb)[i] ), i, pos = 1 )
let.mon <- ls (pattern = "^[A-Z]{2}?[a-z]{2}?")
let.mon[3:6]
sapply (let.mon, function(i) object.size(get(i)))
remove (list = grep ("^[A-Z]{2}?[a-z]{2}?", ls(), value = T ) )
