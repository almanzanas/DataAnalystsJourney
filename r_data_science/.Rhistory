<li>Elemento de lista 3</li>
</ul>
<a href="https://www.ejemplo.com">Visita nuestro sitio web</a>
</body>
</html>
')
no.html <- gsub ( "<.*?>", "", html)
gsub ("\\n", "", no.html)
cat(no.html)
# Linux to Windows
gsub ("/", "\\\\", "/usr/local/bin")
# Windows to Linux
gsub("\\\\", "/", "\\usr\\local\\bin")
gsub("\\", "/", "\\usr\\local\\bin", fixed = TRUE)
(yogi <- "It's d\xe9j\xe0 vu all over again.")
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("‘a", yogi) )
yogi <- "It's d\xe9j\xe0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
?iconv
yogi <- "It's d\xe9j\xe0 vu all over again."
cat(yogi)
yogi.utf8 <- iconv (yogi, latin1, utf8)
yogi <- "It's d\Ue9j\Ue0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
yogi <- "It's d\Ue9j\Ue0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
yogi.lat <- "It's d\\xe9j\\xe0 vu all over again."
Encoding (yogi.utf)
Encoding (yogi.lat)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
yogi.lat <- "It's d\\xe9j\\xe0 vu all over again." |> iconv("latin1", "UTF-8")
Encoding (yogi.utf)
Encoding (yogi.lat)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
Encoding (yogi.utf)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
Encoding (yogi.utf)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.utf), regexpr ("à", yogi.utf) )
data.frame (a = "\U4e2d\U56fd", stringsAsFactors = FALSE)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
lables(cols.fac)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac)["blue"]
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac["blue"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac["red"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
table(cols.fac[cols.fac != "red"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
table(cols.fac[cols.fac != "red"])
levels(cols.fac)
levels(cols.fac)[2] <- "yellow"
levels(cols.fac)
factor (cols.fac, levels = c("red", "blue", "yellow") )
cols.fac
factor (cols.fac, levels = c("red", "blue", "yellow") )
ind <- factor ( c(3, 4, 6, 33, 66, 77) )
src <- 101:199
# as.numeric will convert the vector elements into its assigned integers, not the levels.
as.numeric(ind)
ind <- factor ( c(33, 4, 66, 3, 6, 77) )
src <- 101:199
# as.numeric will convert the vector elements into its assigned integers, not the levels.
as.numeric(ind)
ind
# Correct way, looking for that indices into 'src' vector:
src[as.numeric (as.character (ind) )]
gender <- as.factor(c("F", "F", "M", "F", "M", "F", "M") )
gender
as.numeric(gender) - 1
mis.fac <- as.factor(c("F", NA, "M", "F", NA, "F", "M") )
mis.fac
mis.fac <- as.character(mis.fac)
mis.fac[is.na (mis.fac)] <- "missing"
( mis.fac <- as.factor(mis.fac) )
for (i in 1:24)
assign (paste0 (LETTERS[i], month.abb), i, pos = 1 )
let.mon <- ls (pattern = "^[A-Z]{2}?[a-z]{2}?")
let.mon[3:6]
sapply (let.mon, function(i) object.size(get(i)))
remove (list = grep ("^[A-Z]{2}?[a-z]{2}?", ls(), value = T ) )
for (i in 1:24)
assign (paste0 (LETTERS[i], (month.abb+month.abb)[i]), i, pos = 1 )
for (i in 1:24)
assign (paste0 (LETTERS[i], c(month.abb,month.abb)[i] ), i, pos = 1 )
let.mon <- ls (pattern = "^[A-Z]{2}?[a-z]{2}?")
let.mon[3:6]
sapply (let.mon, function(i) object.size(get(i)))
remove (list = grep ("^[A-Z]{2}?[a-z]{2}?", ls(), value = T ) )
sqplus <- function (x, y = 2) {
# y default value is 2
# Args: x, numeric;
#       y, numeric;
if (x < 0) {
warning ("Negative number cannot be operated")
return (NA)
}
return (sqrt (x) + y)
}
# Trying the new function 'sqplus'
sqplut (x=9, y=3)
sqplus <- function (x, y = 2) {
# y default value is 2
# Args: x, numeric;
#       y, numeric;
if (x < 0) {
warning ("Negative number cannot be operated")
return (NA)
}
return (sqrt (x) + y)
}
# Trying the new function 'sqplus'
sqplus (x=9, y=3)
fix(text)
cat(" Hola Mundo")
browser()
blanks
q
?stopifnot
a <- function (arg1) {
if (missing (arg1)) stop ("Missing argument in a!")
return (arg1^2)
}
b <- function (input = 9, offset) {
a.result <- a (offset)
return (input + a.result)
}
b()
traceback()
b <- function (input = 9, offset) {
a.check <- try (a.result <- a (offset) )
if (class (a.check)[1] == "try-error") {
warning ("Call to a() faiuled; setting a.result = 3")
a.result <- 3
}
return (input + a.result)
}
b()
b <- function (input = 9, offset) {
a.check <- try (a.result <- a (offset) )
if (class (a.check)[1] == "try-error") {
warning ("Call to a() failed; setting a.result = 3")
a.result <- 3
}
return (input + a.result)
}
b()
Sys.getenv()
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
f1(vec)
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
f1(5)
# Vectorized
f2 <- function (x, y = 2) {
out <- as.numeric (rep(NA, length(x)))
if (any(x < 0)) warning ("Neg(s)")
out[x >= 0] <- sqrt(x[x > 0]) + y
return (out)
}
f2(5)
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
apply(vec, FUN=f1)
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
f1(5)
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=600,000,000
system.time (what (6e8) )
# compiling and testing again:
what.cmp <- cmpfun(what)
library(compiler)
what.cmp <- cmpfun(what)
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=600,000,000
system.time (what (6e8) )
# compiling and testing again:
library(compiler)
what.cmp <- cmpfun(what)
system.time (what.cmp (6e8))
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=600,000,000
system.time (what (6e12) )
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=6,000,000,000
system.time (what (6e9) )
# compiling and testing again:
library(compiler)
what.cmp <- cmpfun(what)
system.time (what.cmp (6e9))
library(parallel)
detectCores()
clust <- makeCluster(10)
clusterExport (clust, c("what", "what.cmp"))
system.time (
parSapply (clust, 1:10, function (i) what (6e9/10))
)
system.time (
parSapply(clust, 1:10, function (i) what.cmp (6e9/10))
)
?scan
getwd()
read.table ("data/addresses.csv", header = TRUE, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE)
read.table ("../data/addresses.csv", header = TRUE, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE)
read.table ("../data/addresses.csv", header = TRUE, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE, nrows = 1)
read.table ("../data/addresses.csv", header = F, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE, nrows = 1)
count.fields ("../data/addresses.csv", sep = ",", quote = "", comment.char = "")
read.table ("../data/addresses.csv", header = F, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE,
nrows = 1, skip = 2)
read.table ("../data/addresses.csv", header = T, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE, fill = T)
(
add <- read.table ("../data/addresses.csv", header = T, sep = ",", quote = "",
comment.char = "", stringsAsFactors = FALSE, fill = T)
)
# Vector with logical values:
fixc <- add$State != ""
# Paste column 2 and 3 from that rows
add[fixc, 2] <- paste (add[fixc, 2], add[fixc, 3])
# Changing the order
add[fixc, 3:4] <- add[fixc, 4:5]
add
# Saving column names and deleting State column
mycols <- colnames (add)
add$State <- NULL
add <- data.frame (ID = rownames (add), add)
colnames (add) <- mycols
# Replace old rownames:
rownames (add) <- NULL
# Removing objects:
rm (fixc, mycols)
add
(
add.scan <- scan ("~/data/addresses.csv", what = character(), sep = "\n",
quote = "", comment.char = "")
)
(
add.scan <- scan ("../data/addresses.csv", what = character(), sep = "\n",
quote = "", comment.char = "")
)
# locating all the commas:
commas <- gregexpr (",", add.scan)
# Extracting long rows:
comma.5 <- lengths (commas) == 5
# Locating the third comma:
comma.gone <- sapply (commas[comma.5], function(x) x[3])
# Replacing comma for semi-colon:
substring (add.scan[comma.5], comma.gone, comma.gone) <- ";"
add.scan
read.table (text = add.scan, header = TRUE, sep = ",", quote = "",
comment = "", stringsAsFactors = FALSE)
read.table (text = add.scan, header = TRUE, sep = ",", quote = "",
comment = "", stringsAsFactors = FALSE,
colClasses = c(ID = "character") )
readLines ("../data/addresses.csv", n = 1)
con.add <- file ("../data/addresses.csv", open = "r")
readLines (con.add, n = 2)
readLines (con.add, n = 2)
close (con.add)
install.packages("RODBC")
sqlcon <- odbcConnect (dsn="SQL2022", uid="rstats", pwd="P@ssw0rd")
library(RODBC)
sqlcon <- odbcConnect (dsn="SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlcon <- odbcConnect (dsn="SQL2022", uid="rstats", pwd="P@ssw0rd")
?odbcConnect
?odbcDriverConnect
sqlcon <- odbcDriverConnect("")
sql.conn <- odbcDriverConnect(connection="{ODBC Driver 18 for SQL Server};SERVER=SQL2022;DATABASE=AdventureWorks2022;UID=rstats;PWD=P@ssw0rd;")
sql.conn <- odbcDriverConnect(connection="SERVER=SQL2022;DATABASE=AdventureWorks2022;UID=rstats;PWD=P@ssw0rd;")
sql.conn <- odbcDriverConnect(connection="DRIVER={ODBC Driver 18 for SQL Server};SERVER=SQL2022;DATABASE=AdventureWorks2022;UID=rstats;PWD=P@ssw0rd;")
sql.conn <- odbcDriverConnect(connection="DRIVER={ODBC Driver 18 for SQL Server};SERVER=SQL2022\\SQL2022;DATABASE=AdventureWorks2022;UID=rstats;PWD=P@ssw0rd;")
sql.conn <- odbcDriverConnect(connection="DRIVER={SQL Server};SERVER=192.168.1.123\\SQL2022;DATABASE=AdventureWorks2022;UID=rstats;PWD=P@ssw0rd;")
sql.conn <- odbcDriverConnect(connection="DRIVER={SQL Server};SERVER=192.168.1.123;DATABASE=AdventureWorks2022;UID=rstats;PWD=P@ssw0rd;")
connection <- odbcConnect("SQL2022")
connection <- odbcConnect("SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlTables(connection)
?sqlTables
sqlTables(connection, schema = "AdventureWorks2022")
connection <- odbcConnect("SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlTables(connection, schema = "%")
sqlTables(connection, tableType = "TABLE")
close(connection)
sqlTables(connection, tableType = "TABLE")
connection <- odbcConnect("SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlTables(connection, tableType = "TABLE")
connection <- odbcConnect("SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlTables(connection, tableType = "TABLE", scheme = "HumanResources")
connection <- odbcConnect("SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlTables(connection, tableType = "TABLE", scheme = "%")
connection <- odbcConnect("SQL2022", uid="rstats", pwd="P@ssw0rd")
sqlTables(connection, scheme = "HumanResources")
sqlTables(connection, tableType = "TABLE")
odbcDriverConnect?
;
?odbcDriverConnect
sqlTables(connection, tableType = "TABLE")[2:6]
adv.tab <- sqlTables(connection, tableType = "TABLE")
adv.tab[2:6]
adv.tab[2:6,]
adv.tab[4:8,]
sqlColumns(connection, "JobCandidate")[3:10,]
sqlColumns(connection, "Employee")[3:10,]
sqlColumns(connection, "Employee")[3:10,4:]
sqlColumns(connection, "Employee")[3:10,4::]
sqlColumns(connection, "Employee")[3:10,4:ncol(sqlColumns(connection, "Employee"))]
emp <- sqlQuery (connection, "
SELECT * FROM Employee
")
emp
?sqlQuery
emp <- sqlQuery (connection, "
SELECT * FROM Employee.AdventureWorks2022
")
emp
emp <- sqlQuery (connection, "
SELECT * FROM AdventureWorks2022.Employee
")
emp
emp <- sqlQuery (connection, "
SELECT * FROM HumanResources.Employee
")
emp
?sample
sample(emp, 8)
sample(emp, c(8,))
sample(emp)
s10 <- sample(nrow(emp), 10)
emp[s10,]
emp.fem <- sqlQuery (connection, "
SELECT * FROM HumanResources.Employee
WHERE Gender == F
", stringAsFactors = FALSE)
emp.fem
emp.fem <- sqlQuery (connection, "
SELECT * FROM HumanResources.Employee
WHERE Gender = F
", stringAsFactors = FALSE)
emp.fem
emp.fem <- sqlQuery (connection, "
SELECT * FROM HumanResources.Employee
WHERE Gender = 'F'
", stringAsFactors = FALSE)
emp.fem <- sqlQuery (connection, "
SELECT * FROM HumanResources.Employee
WHERE Gender == 'F'
", stringAsFactors = FALSE)
emp.fem
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
", stringAsFactors = FALSE)
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
", stringsAsFactors = FALSE)
emp.mal
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
WHERE Gender = M
", stringsAsFactors = FALSE)
emp.mal
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
WHERE Gender = 'M'
", stringsAsFactors = FALSE)
emp.mal
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
WHERE Gender = 'F'
", stringsAsFactors = FALSE)
emp.mal
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
WHERE Gender = 'M'
", stringsAsFactors = FALSE)
emp.mal
emp.mal <- sqlQuery (connection, "
SELECT BusinessEntityID, LoginID, VacationHours, SickLeaveHours
FROM HumanResources.Employee
WHERE Gender = 'M'
", stringsAsFactors = FALSE)
s10 <- sample(nrow(emp.mal), 10)
emp.mal[s10,]
emp.sales <- sqlQuery (connection, "
SELECT *
FROM Sales.SalesPerson
LEFT JOIN HumanResources.Employee
ON BusinessEntityID
", stringsAsFactors = FALSE)
s10 <- sample(nrow(emp.sales), 10)
emp.sales <- sqlQuery (connection, "
SELECT *
FROM Sales.SalesPerson
LEFT JOIN HumanResources.Employee
ON Sales.SalesPerson.BusinessEntityID = HumanResources.Employee.BusinessEntityID
", stringsAsFactors = FALSE)
s10 <- sample(nrow(emp.sales), 10)
emp.sales
emp.sales <- sqlQuery (connection, "
SELECT *
FROM Sales.SalesPerson
LEFT JOIN HumanResources.Employee
ON Sales.SalesPerson.BusinessEntityID = HumanResources.Employee.BusinessEntityID
", stringsAsFactors = FALSE)
# s10 <- sample(nrow(emp.sales), 10)
emp.sales
?sqlGetResults
sqlFetch(connection, "Sales.Customer")
?sqlFetch
sqlFetch(connection, "Sales.Customer", max(10))
sqlFetch(connection, "Sales.Customer", max = 10)
sqlFetchMore(connection, max = 10)
close(connection)
list.files(pattern = "^babyname*")
?list.files
list.files(pattern = "^babyname*", recursive = TRUE, full.names = TRUE)
list.files(pattern = "^babyname", recursive = TRUE, full.names = TRUE)
list.files(pattern = "^baby*$", recursive = TRUE, full.names = TRUE)
list.files(path = "~/" , pattern = "^baby*$", recursive = TRUE, full.names = TRUE)
path.expand("~")
list.files(path = getwd() , pattern = "^baby*$", recursive = TRUE, full.names = TRUE)
getwd()
list.files(path = getwd() ,
#pattern = "^baby*$", r
ecursive = TRUE, full.names = TRUE)
list.files(path = getwd() ,
#pattern = "^baby*$", r
recursive = TRUE, full.names = TRUE)
list.files(path = getwd() ,
#pattern = "^baby*$",
recursive = TRUE, full.names = F)
list.files(path = "../" ,
#pattern = "^baby*$",
recursive = TRUE, full.names = F)
list.files(path = "../" ,
pattern = "^baby*$",
recursive = TRUE, full.names = F)
list.files(path = "../" ,
pattern = "^baby*",
recursive = TRUE, full.names = F)
getwd()
unzip("../data/babynames/babynames-1950.zip", list = TRUE)
