sprintf ("spent $%*.2f in %s",
bigs, costs, month.name[2:6] )
bigs <- max (nchar (sprintf ("%.2f", costs) ) )
sprintf ("spent $%*.2f in %s \n",
bigs, costs, month.name[2:6] )
bigs <- max (nchar (sprintf ("%.2f", costs) ) )
sprintf ("spent $%*.2f in %s",
bigs, costs, month.name[2:6] )
sprintf ("%03d", 1:15 )
100000
c( 1, 100000 )
c( 1, 100000, 123456 )
as.integer (1000000 + 1 )
format ( 1000000, scientific=FALSE)
vec <- c(1, 5, 7, 2, 8, 9, 3, 4, 10)
as.character (cut (vec, c(1, 4, 7, 10), include.lowest=TRUE, right=FALSE) )
# Generating random numbers
set.seed(168)
rand.vec <- rnorm(1000)
# cut() with breaks=5 of equal width
table (cut (rand.vec, breaks=5) )
# Using quantile() to create bins with equal number of observations
table (cut (rand.vec, quantile(rand.vec) ) )
?cut
?quantile
# Generating random numbers
set.seed(168)
rand.vec <- rnorm(1000)
# cut() with breaks=5 of equal width
table (cut (rand.vec, breaks=5) )
# Using quantile() to create bins with equal number of observations
table (cut (rand.vec, quantile(rand.vec) ) )
# quantile() with probs argument to create 5 bins instead of 2
table (cut (rand.vec,
quantile(rand.vec, probs=seq(0, 1, 0.2) ),
include.lowest = TRUE ) )
paste("a", "b", "c")
paste0( 1 == 2, 1 + 2)
paste0("Arg", LETTERS[3:7], sep=".")
paste(letters[1:5], LETTERS[5:1], collapse = "\n")
paste("a", "b", "c")
paste0( 1 == 2, 1 + 2)
paste0("Arg", sep=".", LETTERS[3:7])
paste(letters[1:5], LETTERS[5:1], collapse = "")
?paste
paste("a", "b", "c")
paste0( 1 == 2, 1 + 2)
paste0("Arg", sep=".", LETTERS[3:7])
paste(letters[1:5], LETTERS[5:1], collapse = ", ")
head (
outer (month.abb, 2016:2018, paste, sep = "." ), 5
)
monseq <- outer (month.abb, 2016:2018, paste, sep = "." )
newnam <- c("ID", paste0 ("Bal.", monseq) )
sample(newnam, 5)
head (
outer (month.abb, 2016:2018, paste, sep = "." ), 5
)
# Creating the month sequence for each year
monseq <- outer (month.abb, 2016:2018, paste, sep = "." )
# Creating the column names
newnam <- c("ID",
paste0 ("Bal.", monseq),
paste0 ("Pay.", monseq) )
sample(newnam, 5)
head (
outer (month.abb, 2021:2023, paste, sep = "." ), 5
)
# Creating the month sequence for each year
monseq <- outer (month.abb, 2021:2023, paste, sep = "." )
# Creating the column names
newnam <- c("ID",
paste0 ("Bal.", monseq),
paste0 ("Pay.", monseq) )
sample(newnam, 5)
# Alternative maybe more eficient but more tedious
p1 <- rep (c("Bal", "Pay"), 12 * 3)
# Each month 2 times for Bal and Pay, and then 3 times for the years
p2 <- rep ( rep(month.abb, each = 2), 3 )
# Each year two times, for Bal and Pay
p3 <- rep (2021:2023, each = 24)
newnam <- c("ID", paste(p1, p2, p3, sep=".") )
sample(newnam, 5)
names.df <- expand.grid (c("Bal", "Pay"),
c(2021:2023),
month.abb,
stringAsFactors=FALSE)
sample(names.df, 5)
names.df <- expand.grid (c("Bal", "Pay"),
c(2021:2023),
month.abb,
stringAsFactors=FALSE)
names.df
names.df <- expand.grid (c("Bal", "Pay"),
month.abb,
c(2021:2023) )
names.df
names.df <- expand.grid (c("Bal", "Pay"),
month.abb,
c(2021:2023) )
names.df
newnam <- paste ( names.df[["Var1"]],
names.df[["Var2"]],
names.df[["Var3"]],
sep = "." )
sample(newnam, 5)
names.df <- expand.grid (c("Bal", "Pay"),
month.abb,
c(2021:2023) )
newnam <- paste ( names.df[["Var1"]],
names.df[["Var2"]],
names.df[["Var3"]],
sep = "." )
sample(newnam, 5)
?expand.grid
gc()
set.seed(168)
rnd.dts <- as.Date (sample (0:730, size = 600), origin = "2021-01-01")
table (quarters (rnd.dts) )
talbe ( paste0 (format (rnd.dts, "%Y"), ".", quarters(rnd.dts) ) )
set.seed(168)
rnd.dts <- as.Date (sample (0:730, size = 600), origin = "2021-01-01")
table (quarters (rnd.dts) )
table ( paste0 (format (rnd.dts, "%Y"), ".", quarters(rnd.dts) ) )
?tapply
ym.order <- paste0 (2021:2023, ".", month.abb )
ym.tbl <- table (format(rnd.dts, "%Y.%b") )
ym.tbl[ym.order][3:7]
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B") )
ym.tbl[ym.order][3:7]
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B"), na.rm=TRUE )
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B") )
ym.tbl[ym.order][3:7]
ym.order <- paste0 (2021:2023, ".", month.name )
ym.tbl <- table (format(rnd.dts, "%Y.%B") )
ym.tbl[ym.order][1:5]
list.files (full.names =TRUE)
paste (getwd(), list.files(), sep="/")
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".[0-3]?[0-9].*(", mo, ").*[1-2][0-9]{3}")
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".[0-3]?[0-9].*(", or.mon, ").*[1-2][0-9]{3}")
grep (re, dt, value = TRUE )
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".*[0-3]?[0-9].*(", or.mon, ").*[1-2][0-9]{3}")
grep (re, dt, value = TRUE )
dt <- c(
"Balance due 16 Jun or earlier in 2017",
"26 Aug or any day in 3021",
"'76 Trombones' marched in a 1962 film",
"4 Apr 2018", "9Aug2006",
"99 Voters May Register in 20188"
)
or.mon <- paste (month.abb, collapse = "|")
or.mon
re <- paste0 ( ".*[0-3]?[0-9].*(", or.mon, ").*[1-2][0-9]{3}")
grep (re, dt, value = TRUE )
pain <- c("c:\\temp", "/bin/u", "$5", "\n", "2 backs: \\\\")
grep ("$", pain)
grep ("\\$", pain, value=TRUE)
grep ("\\\\", pain, value=TRUE)
grep ("\\", pain, value=TRUE, fixed=TRUE)
# Looking for any slashes:
grep ("\\|/", pain, value=TRUE, fixed=FALSE)
?grep
?regex
dt
# looking for a word with an integer:
(regout <- regexpr( "\\<\\d+\\>", dt ) )
attr(,"match.legth")
dt
# looking for a word with an integer:
(regout <- regexpr( "\\<\\d+\\>", dt ) )
attr(,"match.legth")
regmatches (dt, regout)
( gout <- gregexpr ("\\<\\d+\\>", dt) )
regmatches (dt, gout)
# Creating a matrix with the return of regmatches
matrix (as.numeric (unlist (regmatches (dt, gout) ) ) )
gout <- gregexpr ("\\<\\d+\\>", dt)
regmatches (dt, gout)
# Creating a matrix with the return of regmatches
matrix (as.numeric (unlist (regmatches (dt, gout) ) ), ncol=2, byrow=T )
?do.call
do.call (regmatches, dt, gout)
do.call (regmatches, gout, dt)
dt |> do.call (regmatches, gout)
?regmatches
do.call (regmatches, gout, x=dt)
do.call (regmatches, list(dt, gout) )
?rbind
bros <- c("Isaac Asimov", "Leon Tolstoi", "Virginia Woldf", "Brandon Sanderson")
# Changing the name order with backreferences:
sub ("([[:alpha:]]+) ([[:alpha:]]+)", "\\2, \\1", bros)
bros <- c("Isaac Asimov", "Leon Tolstoi", "Virginia Wolf", "Brandon Sanderson")
# Changing the name order with backreferences:
sub ("([[:alpha:]]+) ([[:alpha:]]+)", "\\2, \\1", bros)
keys <- c("CA-2017-04-02-66J-44",
"MI-2017-07-17-41H-72",
"CA-2017-08-24-Missing-378")
(key.list <- strsplit (keys, "-") )
matrix ( unlist (key.list), ncol = 6, byrow = TRUE )
install.packages("ymlthis")
ymlthis:::launch_yaml_addin()
gsub ( "^ *| *$", "", c("  Text Spaces ", "Trailing    ",
"None", "     Leading" ) )
as.numeric ( gsub ("(^[^0-9.]|,)|(,|[^[:digit:].]$",
"", c("$12,345.67", "98,765.43€") ) )
as.numeric ( gsub ("(^[^0-9.]|,)|(,|[^[:digit:].]$)",
"", c("$12,345.67", "98,765.43€") ) )
html <- c('
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ejemplo de HTML</title>
</head>
<body>
<h1>Bienvenido a mi página web</h1>
<p>Este es un <strong>ejemplo</strong> de un párrafo con <em>texto en cursiva</em> y <strong>texto en negrita</strong>.</p>
<ul>
<li>Elemento de lista 1</li>
<li>Elemento de lista 2</li>
<li>Elemento de lista 3</li>
</ul>
<a href="https://www.ejemplo.com">Visita nuestro sitio web</a>
</body>
</html>
')
gsub ( "<.*?>", "", html)
html <- c('
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ejemplo de HTML</title>
</head>
<body>
<h1>Bienvenido a mi página web</h1>
<p>Este es un <strong>ejemplo</strong> de un párrafo con <em>texto en cursiva</em> y <strong>texto en negrita</strong>.</p>
<ul>
<li>Elemento de lista 1</li>
<li>Elemento de lista 2</li>
<li>Elemento de lista 3</li>
</ul>
<a href="https://www.ejemplo.com">Visita nuestro sitio web</a>
</body>
</html>
')
no.html <- gsub ( "<.*?>", "", html)
gsub ("\\n", "", no.html)
cat(no.html)
# Linux to Windows
gsub ("/", "\\\\", "/usr/local/bin")
# Windows to Linux
gsub("\\\\", "/", "\\usr\\local\\bin")
gsub("\\", "/", "\\usr\\local\\bin", fixed = TRUE)
(yogi <- "It's d\xe9j\xe0 vu all over again.")
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("‘a", yogi) )
yogi <- "It's d\xe9j\xe0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
?iconv
yogi <- "It's d\xe9j\xe0 vu all over again."
cat(yogi)
yogi.utf8 <- iconv (yogi, latin1, utf8)
yogi <- "It's d\Ue9j\Ue0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
yogi <- "It's d\Ue9j\Ue0 vu all over again."
cat(yogi)
Encoding (yogi)
c( regexpr ("\\xe0", yogi), regexpr ("\ue0", yogi), regexpr ("à", yogi) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
yogi.lat <- "It's d\\xe9j\\xe0 vu all over again."
Encoding (yogi.utf)
Encoding (yogi.lat)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
yogi.lat <- "It's d\\xe9j\\xe0 vu all over again." |> iconv("latin1", "UTF-8")
Encoding (yogi.utf)
Encoding (yogi.lat)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
Encoding (yogi.utf)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.lat), regexpr ("à", yogi.lat) )
yogi.utf <- "It's d\Ue9j\Ue0 vu all over again."
Encoding (yogi.utf)
c( regexpr ("\\xe0", yogi.utf), regexpr ("\ue0", yogi.utf), regexpr ("à", yogi.utf) )
data.frame (a = "\U4e2d\U56fd", stringsAsFactors = FALSE)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
lables(cols.fac)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac)
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac)["blue"]
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac["blue"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
labels(cols.fac["red"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
levels(cols.fac)
table(cols.fac[cols.fac != "red"])
cols.fac <- as.factor( c("red", "green", "blue", "red", "red", "red", "blue") )
cols.fac
table(cols.fac[cols.fac != "red"])
levels(cols.fac)
levels(cols.fac)[2] <- "yellow"
levels(cols.fac)
factor (cols.fac, levels = c("red", "blue", "yellow") )
cols.fac
factor (cols.fac, levels = c("red", "blue", "yellow") )
ind <- factor ( c(3, 4, 6, 33, 66, 77) )
src <- 101:199
# as.numeric will convert the vector elements into its assigned integers, not the levels.
as.numeric(ind)
ind <- factor ( c(33, 4, 66, 3, 6, 77) )
src <- 101:199
# as.numeric will convert the vector elements into its assigned integers, not the levels.
as.numeric(ind)
ind
# Correct way, looking for that indices into 'src' vector:
src[as.numeric (as.character (ind) )]
gender <- as.factor(c("F", "F", "M", "F", "M", "F", "M") )
gender
as.numeric(gender) - 1
mis.fac <- as.factor(c("F", NA, "M", "F", NA, "F", "M") )
mis.fac
mis.fac <- as.character(mis.fac)
mis.fac[is.na (mis.fac)] <- "missing"
( mis.fac <- as.factor(mis.fac) )
for (i in 1:24)
assign (paste0 (LETTERS[i], month.abb), i, pos = 1 )
let.mon <- ls (pattern = "^[A-Z]{2}?[a-z]{2}?")
let.mon[3:6]
sapply (let.mon, function(i) object.size(get(i)))
remove (list = grep ("^[A-Z]{2}?[a-z]{2}?", ls(), value = T ) )
for (i in 1:24)
assign (paste0 (LETTERS[i], (month.abb+month.abb)[i]), i, pos = 1 )
for (i in 1:24)
assign (paste0 (LETTERS[i], c(month.abb,month.abb)[i] ), i, pos = 1 )
let.mon <- ls (pattern = "^[A-Z]{2}?[a-z]{2}?")
let.mon[3:6]
sapply (let.mon, function(i) object.size(get(i)))
remove (list = grep ("^[A-Z]{2}?[a-z]{2}?", ls(), value = T ) )
sqplus <- function (x, y = 2) {
# y default value is 2
# Args: x, numeric;
#       y, numeric;
if (x < 0) {
warning ("Negative number cannot be operated")
return (NA)
}
return (sqrt (x) + y)
}
# Trying the new function 'sqplus'
sqplut (x=9, y=3)
sqplus <- function (x, y = 2) {
# y default value is 2
# Args: x, numeric;
#       y, numeric;
if (x < 0) {
warning ("Negative number cannot be operated")
return (NA)
}
return (sqrt (x) + y)
}
# Trying the new function 'sqplus'
sqplus (x=9, y=3)
fix(text)
cat(" Hola Mundo")
browser()
blanks
q
?stopifnot
a <- function (arg1) {
if (missing (arg1)) stop ("Missing argument in a!")
return (arg1^2)
}
b <- function (input = 9, offset) {
a.result <- a (offset)
return (input + a.result)
}
b()
traceback()
b <- function (input = 9, offset) {
a.check <- try (a.result <- a (offset) )
if (class (a.check)[1] == "try-error") {
warning ("Call to a() faiuled; setting a.result = 3")
a.result <- 3
}
return (input + a.result)
}
b()
b <- function (input = 9, offset) {
a.check <- try (a.result <- a (offset) )
if (class (a.check)[1] == "try-error") {
warning ("Call to a() failed; setting a.result = 3")
a.result <- 3
}
return (input + a.result)
}
b()
Sys.getenv()
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
f1(vec)
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
f1(5)
# Vectorized
f2 <- function (x, y = 2) {
out <- as.numeric (rep(NA, length(x)))
if (any(x < 0)) warning ("Neg(s)")
out[x >= 0] <- sqrt(x[x > 0]) + y
return (out)
}
f2(5)
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
apply(vec, FUN=f1)
# Non-Vectorized:
f1 <- function (x, y = 2) {
if (x < 0) {
warning ("Neg(s)")
return (NA)
}
return (sqrt(x) + y)
}
f1(5)
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=600,000,000
system.time (what (6e8) )
# compiling and testing again:
what.cmp <- cmpfun(what)
library(compiler)
what.cmp <- cmpfun(what)
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=600,000,000
system.time (what (6e8) )
# compiling and testing again:
library(compiler)
what.cmp <- cmpfun(what)
system.time (what.cmp (6e8))
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=600,000,000
system.time (what (6e12) )
what <- function (n = 100) {
for (i in 1:n) {}
}
# timing the function 'what' n=6,000,000,000
system.time (what (6e9) )
# compiling and testing again:
library(compiler)
what.cmp <- cmpfun(what)
system.time (what.cmp (6e9))
library(parallel)
detectCores()
clust <- makeCluster(10)
clusterExport (clust, c("what", "what.cmp"))
system.time (
parSapply (clust, 1:10, function (i) what (6e9/10))
)
system.time (
parSapply(clust, 1:10, function (i) what.cmp (6e9/10))
)
